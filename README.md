# haskell-io
Repository to study and implement exercises done in haskell introductory course.


# Lista 01

Escreva a resposta dos exercÃ­cios abaixo no cÃ³digo `lista01/src/Main.hs` antes da funÃ§Ã£o `main`. Para testar, adicione uma linha a funÃ§Ã£o `main` da seguinte forma:

```haskell
main = do
  putStrLn "Hello World"
  print $ funcao parametro
```

Os exercÃ­cios que nÃ£o necessitam de implementaÃ§Ã£o devem ser deixados em forma de comentÃ¡rios. Exemplo de cÃ³digo contendo a resposta dos exercÃ­cios 1a, 2a e 6a:

```haskell
{- 
Exercicio 01:
1.2 :: Floating a => a
-}

{-
ExercÃ­cio 02:
subtrair :: Integral a => a -> a -> a
-}

-- ExercÃ­cio 06
maximo :: Ord a => a -> a -> a
maximo x y = if x > y then x else y

minimo :: Ord a => a -> a -> a
minimo x y = if x < y then x else y

main :: IO ()
main = do
  print $ maximo 4 2
  print $ minimo 4 2
```

Para testar o programa basta fazer no prompt de comando do terminal no diretÃ³rio *lista01*:

```bash
stack run 
```

# Tipos e Polimorfismo

1. Sem utilizar qualquer ajuda, determine o Tipo das seguintes expressÃµes. Depois, utilize o *ghci* para confirmar suas respostas.


- `1.2` 
- `[1, 2]`
- `(1, 2)`
- `"1, 2"`
- `'ğŸ¤”'`


2. Defina as assinaturas de tipo e implemente as funÃ§Ãµes abaixo:

- FunÃ§Ã£o `subtrair`, que recebe dois valores inteiros e retorna a diferenÃ§a do primeiro pelo segundo
- FunÃ§Ã£o `dobro`, que recebe um valor inteiro e retorna o seu dobro
- FunÃ§Ã£o `quad`, que recebe um valor inteiro e retorna seu quadrado
- FunÃ§Ã£o `cumprimentar`, que recebe um nome e retorna "OlÃ¡ *nome*" (considere o operador de concatenaÃ§Ã£o `++`)
- FunÃ§Ã£o `aniversario`, que recebe um ano de nascimento e retorna a string "VocÃª farÃ¡ __ anos em 2020!"


3. Considere um algoritmo de [hashing](https://pt.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_hash_criptogr%C3%A1fica) criptogrÃ¡fico (md5, sha2) Ã© utilizado para criptografar textos, transformando-os em sequÃªncias de caracteres embaralhadas, aparentemente "aleatÃ³rias". Qual seria o tipo dessa funÃ§Ã£o em Haskell?

4. VocÃª foi contratado para desenvolver um jogo de cartas online, em Haskell. Uma carta Ã© definida por `(Char, Char)`, em que o primeiro Ã© o valor da carta (`2-9`, `0`, `J`, `Q`, `K`, `A`) e o segundo representa o naipe (`â™ `, `â™¦`, `â™£`, `â™¥`). Considere que nÃ£o existe Coringa. Escreva uma funÃ§Ã£o que compute o valor de uma carta em um jogo de buraco:
  - 3-7 valem 5
  - 8-K valem 10
  - 2 vale 10
  - A vale 15

5. FaÃ§a uma funÃ§Ã£o `Int -> String` que receba um nÃºmero e retorne o seu correspondente no desafio [FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz). Considere usar as funÃ§Ãµes `show` e `mod`. Exemplos:
- `fb 1 == "1"`
- `fb 3 == "Fizz"`
- `fb 5 == "Buzz"`
- `fb 15 == "FizzBuzz"`

6. Defina as assinaturas e implemente as funÃ§Ãµes abaixo:
- FunÃ§Ã£o `maximo` e `minimo`, que retornam o maior e menor valor, respectivamente
- FunÃ§Ã£o `media`, que retorna o valor mÃ©dio entre dois valores numÃ©ricos
- FunÃ§Ã£o `xou`, que realiza a operaÃ§Ã£o "ou exclusivo" em dois booleanos
- FunÃ§Ã£o `ehQuadradoPerfeito :: Int -> Bool` que determina se um nÃºmero Ã© quadrado perfeito (considere a funÃ§Ã£o `fromIntegral`)
- FunÃ§Ã£o `ehSaudavel :: Int -> Bool -> Bool -> Bool` que receba idade (Int), se come pizzas (Bool), se faz exercÃ­cios de manhÃ£ (Bool) e retorne um Bool de acordo com a Ã¡rvore abaixo 

![](https://miro.medium.com/max/820/0*LHzDR-s89Ggfqn7p.png)

# Listas

1. DÃª o tipo das expressÃµes abaixo, e verifique no ghci
- `[1,2,3]`
- `[1.0, 2.5]`
- `['o', 'l', 'a']`
- `"ola"`
- `[(3, True, 'b'), (10, False, 'Ã‡')]`
- `[]`
- `[[]]`
- `[[], []]`

2. Gere as seguintes listas utilizando ranges
- `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`
- `[2,4,6,8,10,12,14,16,18,20]`
- `"abcdefghijklmnopqrstuvwxyz"`
- `"KLMNOPQRSTUVWXYZ"`

3. FaÃ§a funÃ§Ãµes `Int -> [String]` que recebam um valor `n` de entrada e retornem uma lista com os `n` primeiros nÃºmeros:
- **Naturais**: `naturais 3 == [0, 1, 2]`
- **Pares positivos**: `pp 3 == [2, 4, 6]`
- **Naturais, mas em ordem decrescente**: `natdesc 3 == [2, 1, 0]`

4. Defina as assinaturas e implemente as funÃ§Ãµes abaixo:
- `isHead a as` que retorna se o elemento `a` Ã© o primeiro da lista `as`
- `isSecond a as` que retorna se o elemento `a` Ã© o segundo da lista `as`
- `isAt n a as` que retorna se o elemento `a` estÃ¡ na `n`-Ã©sima posiÃ§Ã£o da lista `as`
- `penultimo as` que retorna o penultimo elemento da lista `as`
- `mediaLista as` que retorna o valor mÃ©dio da lista `as`

5. Defina uma funÃ§Ã£o `mediaJusta` que recebe uma lista **ordenada** de `Float`, descarta o maior e o menor, e entÃ£o calcula a mÃ©dia

6. Defina uma funÃ§Ã£o `mediaGlobal` que receba uma `[[Float]]` e retorne a media das medias de todas as listas. Defina tambÃ©m uma funÃ§Ã£o `mediaJustaGlobal` que faÃ§a o mesmo, utilizando `mediaJusta`

7 Defina as assinaturas e implemente as funÃ§Ãµes abaixo, usando Pattern Matching:
- `isHead' a as` que retorna se o elemento `a` Ã© o primeiro da lista `as`
- `isSecond' a as` que retorna se o elemento `a` Ã© o segundo da lista `as`
- `isFirstEqualThird as` que retorna se o primeiro elemento Ã© igual ao terceiro da lista. Exemplo `isFirstEqualThird [1,2,1,40] == True`

8. Gere as seguintes listas utilizando CompreensÃ£o de Listas:

- [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]
- [1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17, 19, 20, 22, 23]

9. Seu cliente do jogo de cartas online pediu para implementar, usando compreensÃ£o de listas, funÃ§Ãµes que gerem
- Um baralho completo
- A lista dos valores de todas as cartas do baralho

10. FaÃ§a uma funÃ§Ã£o `Int -> [String]` que receba um valor `n` de entrada e retorne uma lista com os `n` primeiros elementos do desafio FizzBuzz

11. Em um determinado sistema de uma e-commerce, desenvolvido em Haskell, um "produto" Ã© uma tupla `(String, Float)`, em que o primeiro elemento Ã© o nome do produto e o segundo Ã© seu preÃ§o. Crie uma funÃ§Ã£o `somarCarrinho` que, dado um carrinho de compras (i.e., uma lista de produtos `[(String, Float)]`) retorne o valor total daquele carrinho.

# RecursÃ£o

1. Defina a funÃ§Ã£o `quadradoMaisProximo n` que recebe um inteiro `n` e retorna, dentre os seus sucessores, o quadrado perfeito mais prÃ³ximo (utilize a funÃ§Ã£o `ehQuadradoPerfeito` escrita por vocÃª!)

2. Defina a funÃ§Ã£o `fib n` que retorna o `n`-Ã©simo termo da sequÃªncia de fibonacci

3. Defina as funÃ§Ãµes `maximo` e `minimo` que recebam uma lista e retornem seus valores mÃ¡ximo e mÃ­nimo

4. DÃª o tipo e defina a funÃ§Ã£o `ehElemento x xs` que retorna True caso `x` seja um elemento da lista `xs`

5. Defina a funÃ§Ã£o `infiniteFib` que gere a lista infinita da sequÃªncia de fibonnaci. Reescreva a funÃ§Ã£o `fib` como `fib' n`, usando as funÃ§Ãµes `take` e `infiniteFib`

6. Utilizando sua funÃ§Ã£o `ehElemento`, escreva a funÃ§Ã£o `removerDuplicados`, que remova os itens duplicados de uma lista

# FunÃ§Ãµes de Alta Ordem

1. RefaÃ§a todos os exercÃ­cios da lista 06 - CompreensÃ£o de listas, mas utilizando funÃ§Ãµes de alta ordem como `map` e `filter`

2. Defina a funÃ§Ã£o `findFirst f xs` que retorne o primeiro elemento de `xs` que satisfaz o predicado `f`

3. Redefina as funÃ§Ãµes `maximo`, `minimo` que recebam uma lista e retornem seus valores mÃ¡ximo e mÃ­nimo

4. Defina as funÃ§Ãµes `map` e `filter` em termos de `fold`s

5. Redefina a funÃ§Ã£o `somarCarrinho` para utilizar o operador de composiÃ§Ã£o

6. Reescreva as funÃ§Ãµes abaixo e explique o que elas fazem:

- `f x = negate (abs x)`
- `f xs = negate (sum (tail xs))`
- `f x = ceiling (negate (tan (cos (max 50 x))))`

# Novos Tipos de Dados

1. Crie os tipos `Produto`, `Carrinho`, `Cartas` e `Baralho`, para correponder aos tipos que usamos durante os exercÃ­cios.

2. Crie o tipo `Pred` que corresponde a um predicado aceito pela funÃ§Ã£o `filter` e `findFirst` (esta Ãºltima definida por vocÃª)

3. Altere a funÃ§Ã£o `ehSaudavel` para receber uma Ãºnica tupla como argumento, e crie o tipo `Saude` para corresponder a essa nova tupla.


## Tipos de Dados AlgÃ©bricos e Classes de Tipo

1. Defina os tipos `Moeda` e `Dinheiro`. `Moeda` Ã© um tipo soma que pode ser `Real`, `Dolar` ou `Euro`. JÃ¡ o tipo `Dinheiro` Ã© um tipo produto contendo um `Double`, representando o saldo disponÃ­vel e `Moeda`, representando qual moeda vocÃª possui. Crie tambÃ©m uma funÃ§Ã£o `cambio :: Dinheiro -> Moeda -> Dinheiro` que realize a conversao do valor recebido como parÃ¢metro para a moeda escolhida. Utilize as cotaÃ§Ãµes do dia.

2. Dado o tipo `Tree` mostrado no curso, defina a instÃ¢ncia `Foldable Tree`. Para ver a mÃ­nima definiÃ§Ã£o completa, utilize `:info Foldable`. SugestÃ£o: implemente `foldr` em pre-ordem.

3. Dados os tipos abaixo, implemente a funÃ§Ã£o `eval :: Expr -> Bool` e defina uma instÃ¢ncia `Show Expr`

```hs
data Op = And | Or
data Expr = Const Bool | Expr Bool Op Bool

-- Exemplos
show $ Expr (Const True) (And) (Expr (Const False) (Or) (Const True)) == "T && (F || T)"
show $ Expr (Const True) (Or) (Expr (Const False) (And) (Const True)) == "(T || F && T)"

eval $ Expr (Const True) (And) (Expr (Const False) (Or) (Const True)) == True
```

## Functores, Applicatives e MÃ´nadas

4. Dado o tipo `data Matriz a = Mat [[a]]`, defina a instancia `Functor Matriz`

5. VocÃª estÃ¡ escrevendo uma _lib_ que faz requisiÃ§Ãµes HTTP para servidores. VocÃª definiu o tipo `data Request a = Loading | Error | Success a`. Defina instÃ¢ncias de Functor, Applicative e Monad para este tipo.

6. Escreva uma funÃ§Ã£o `cumprimenta :: String -> Int -> IO ()` que receba o nome e o ano de nascimento de uma pessoa e mostre a mensagem "OlÃ¡, Fulano! VocÃª farÃ¡ X anos em 2020!"

7. Escreva uma funÃ§Ã£o `voceEstaVelho :: Int -> IO ()` que receba o ano de nascimento de uma pessoa e apresenta um menu para a pessoa escolher dentre as opÃ§Ãµes:

- "1. Calcular idade atual": mostra a idade que essa pessoa farÃ¡ em 2020 e retorna ao menu
- "2. Calcular outra idade": pede um ano inteiro X, mostra a idade que a pessoa farÃ¡ em X e retorna ao menu
- "3. Sair": termina a execuÃ§Ã£o da funÃ§Ã£o